/*
**用C语言实现的DES加密算法
**代码运行实例 http://ideone.com/121102
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//获取src的第i位
#define GETBITBI(src,i) (byte)((src) & (0x80 >> ((i)-1)))
//获取src的第i位 并把它移到第j位
#define GETBIT(src,i,j) (byte)(((src) & (0x80 >> ((i)-1)))?(0x80 >> ((j)-1)) : 0x00)
//将从1开始的比特序号index转化为第几个字节
#define BI(index) (((index)-1)/8)
//将从1开始的比特序号index转化为第某个字节里的第几位比特
#define BJ(index) (((index)-1)%8 + 1)

#define ROTL4(src,h)                                    \
    src[0] = (src[0] << 1) | (GETBIT(src[1],1,8));        \
    src[1] = (src[1] << 1) | (GETBIT(src[2],1,8));        \
    src[2] = (src[2] << 1) | (GETBIT(src[3],1,8));        \
    src[3] = (src[3] << 1) | (h)
//循环左移1位，注意h表示第一个字节的第1位比特，是要移动到最后一个比特的第3位（对于28bit来说）
//取第一个字节的第1位不能再直接用GETBIT宏，要先暂存第1位比特，否则获取到的是移位后的第1位比特，即原第2位比特

typedef unsigned char byte;
//指向所有子密钥（每6个字节一个子密钥）
byte *kk = NULL;

//密钥扩展置换选择1选择表
int keyrptC[28] = {57, 49, 41, 33, 25, 17,  9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36};
int keyrptD[28] = {63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4};
//密钥扩展置换选择2选择表
int keyrptC2[24] = {14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10, 23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2};
int keyrptD2[24] = {41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32};

//IP置换表
int iprpt[64] = {58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
                 57, 49, 41, 33, 25, 17,  9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7};
//逆IP置换表
int invip[64] = {40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29,
                 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41,  9, 49, 17, 57, 25};

//加密函数选择运算E
int rpte[48] = { 32,  1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,  8,  9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
                 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,  1};
//加密函数置换运算P
int rptp[32] = { 16,  7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26,  5, 18, 31, 10, 2,  8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25};
//S盒
int sbt[8][4][16]=//S1
              {{{14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7}, {0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8},
                {4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0}, {15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13}},
                //S2
               {{15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10}, {3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5},
                {0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15}, {13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9}},
                //S3
               {{10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8}, {13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1},
                {13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7}, {1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12}},
                //S4
               {{7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15}, {13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9},
                {10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4}, {3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14}},
                //S5
               {{2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9}, {14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6},
                {4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14}, {11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3}},
                //S6
               {{12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11}, {10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8},
                {9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6}, {4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13}},
                //S7
               {{4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1}, {13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6},
                {1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2}, {6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12}},
                //S8
               {{13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7}, {1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2},
                {7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8}, {2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11}}};

void rpselByTable(byte *src, int table[], int n)
//将src所指字节通过table表进行置换，n指要出置换的比特个数
{
    int i = 0;
    int nbytes = n/8 < n/8.0 ? n/8 + 1 : n/8;
    byte dst[8] = {0,0,0,0,0,0,0,0};

    for(i=0; i<n; i++)
    {
        dst[i/8] = dst[i/8] | GETBIT(src[BI(table[i])], BJ(table[i]), i%8 + 1);
    }
    memcpy(src, dst, nbytes);
}

void keyExpand(byte key[])
//密钥扩展，输入为64位初始密钥，密钥扩展过程输出至文本文件keyExpand.txt
{    
    int i = 0, j = 0;
    byte hc, hd, *kp = NULL;
    byte c[4], d[4];

    kk = (byte *)malloc(16 * 6 * sizeof(byte));
    c[0] = c[1] = c[2] = c[3] = 0;
    d[0] = d[1] = d[2] = d[3] = 0;

    //置换选择1
    for(i = 0; i < 28; i++)
    {
        c[i/8] = c[i/8] | GETBIT(key[BI(keyrptC[i])], BJ(keyrptC[i]), i%8 + 1);
    }

    for(i = 0; i < 28; i++)
    {
        d[i/8] = d[i/8] | GETBIT(key[BI(keyrptD[i])], BJ(keyrptD[i]), i%8 + 1);
    }

    //子密钥16轮
    kp = kk;
    for(i = 0; i < 16; i++)
    {    
        //循环左移位
        if(0 == i || 1 ==i || 8 == i || 15 == i)
        {
            //取最高位为第28位, 循环左移，最高位移到第28位
            hc = GETBIT(c[0],1,4);
            hd = GETBIT(d[0],1,4);            
            ROTL4(c,hc);
            ROTL4(d,hd);
        }
        else  //循环左移2位
        {
            //取最高位为第28位, 循环左移，最高位移到第28位
            hc = GETBIT(c[0],1,4);
            hd = GETBIT(d[0],1,4);            
            ROTL4(c,hc);
            ROTL4(d,hd);

            hc = GETBIT(c[0],1,4);
            hd = GETBIT(d[0],1,4);            
            ROTL4(c,hc);
            ROTL4(d,hd);
        }

        //置换选择2
        kp[0] = 0;    kp[1] = 0;    kp[2] = 0;    kp[3] = 0;    kp[4] = 0;    kp[5] = 0;
        for(j=0; j<48; j++)
        {
            if(j < 24)
            {
                kp[j/8] = kp[j/8] | GETBIT(c[BI(keyrptC2[j])], BJ(keyrptC2[j]), j%8 + 1);
            }
            else
            {
                kp[j/8] = kp[j/8] | GETBIT(d[BI(keyrptD2[j-24] - 28)], BJ(keyrptD2[j-24] - 28), j%8 + 1);
            }
        }
        kp = (kp+6);
    }
}

void sbox(byte *src)
//48bit通过查表输出32bit，S盒置换
{
    int i,di;
    byte x = 0, y = 0;
    byte dst[4] = {0,0,0,0};

    di = 0;
    for(i = 0; i < 48; i++)//逐位处理,  1~6,7~12,13~18,19~24,25~30,31~36,37~42,43~48
    {
        if(0 == i%6){
            x = 0; y = 0;
        }
        switch(i%6 + 1)
        {
            case 1://i=0, 6, 12, 18, 24, 30, 36, 42
                x = x | GETBIT(src[i/8],i%8 + 1,7);
                break;
            case 2://i=1, 7, 13, 19, 25, 31, 36, 43
                y = y | GETBIT(src[i/8],i%8 + 1,5);
                break;
            case 3://i=2, 8, 14, 20, 26, 32, 37, 44
                y = y | GETBIT(src[i/8],i%8 + 1,6);
                break;
            case 4://i=3, 9, 15, 21, 27, 33, 38, 45
                y = y | GETBIT(src[i/8],i%8 + 1,7);
                break;
            case 5://i=4, 10, 16, 22, 28, 34, 39, 46
                y = y | GETBIT(src[i/8],i%8 + 1,8);
                break;
            case 6://i=5, 11, 17, 23, 39, 35, 40, 47
                x = x | GETBIT(src[i/8],i%8 + 1,8);
                dst[di] = (dst[di] << 4) | sbt[i/6][x][y];
                if(0 == (i+1)%12){
                    di++;
                }
                break;
        }
    }
    memcpy(src, dst, 4);
}

void fun(byte *s, byte *k)
//加密函数f
{
    rpselByTable(s, rpte, 48);                            //<<===========1 置换E
    s[0] = s[0]^k[0]; s[1] = s[1]^k[1]; s[2] = s[2]^k[2]; //<<===========2 密钥加
    s[3] = s[3]^k[3]; s[4] = s[4]^k[4]; s[5] = s[5]^k[5];
    sbox(s);                                              //<<===========3 S盒置换
    rpselByTable(s, rptp, 32);                            //<<===========4 置换E
}

void swap(void **a, void **b)
{
    void *t = NULL;
    t = (*a);    (*a) = (*b);    (*b) = t;
}

void encrption(byte m[], byte c[], byte key[], int op)
//用op标记加密解密，加密op = 1，解密op = 0
{
    int i = 0;
    byte *L = NULL, *R = NULL, *t = NULL;
    byte s[8] = {0,0,0,0,0,0,0,0};

    L = (byte *)malloc(4 * sizeof(byte));
    R = (byte *)malloc(4 * sizeof(byte));
    t = (byte *)malloc(8 * sizeof(byte));

    memcpy(s, m, 8);

    keyExpand(key);                                   //<<===========1 密钥扩展
    rpselByTable(s,iprpt,64);                         //<<===========2 IP置换
    memcpy(L, &s[0], 4);                              //<<===========3 拆分左右LR两部分
    memcpy(R, &s[4], 4);
    for(i=0; i<16; i++)
    {
        t = memcpy(t, R, 4);
        if(1 == op)
        {
            fun(t,&kk[i*6]);                              //<<===========4 R进行加密函数f运算
            //0 6 12 18 24 30 36 ... 6*15            
        }
        else if(0 == op)
        {
            fun(t,&kk[6*15 - i*6]);                       //<<===========4 R进行加密函数f运算
            //6*15 5*16 ... 12 6 0        
        }
        else
        {
            exit(0);
        }
        L[0] = L[0] ^ t[0]; L[1] = L[1] ^ t[1];       //<<===========5 加密函数f运算结果加L
        L[2] = L[2] ^ t[2]; L[3] = L[3] ^ t[3];
        swap(&L, &R);                                   //<<===========6 L,R交换
    }
    memcpy(&s[0], R, 4);                              //<<===========7 L,R合并
    memcpy(&s[4], L, 4);
    rpselByTable(s,invip,64);                         //<<===========8 逆IP变换
    memcpy(c, s, 8);                                  //<<===========9 得到密文C
}

char buff[75];        //输出字符串缓冲区
void byteOtf(FILE *fp, byte *src, int nbits, char op)
{
    int i = 0, j = 0;
    if('h' == op)       //以十六进制格式输出
    {        
        int nbytes = nbits/8 < nbits/8.0 ? nbits/8 + 1 : nbits/8;
        for(i = 0; i<nbytes; i++)
        {
            if(0 != i && 0 == i%4)
            {
                sprintf(&buff[j], "                            ");
                j += 28;
            }
            sprintf(&buff[j], "%02x", src[i]);
            j += 2;
        }
        buff[j] = '\0';
    }
    else if('b' == op)  //以二进制格式输出
    {
        for(i = 0; i<nbits; i++)
        {
            if(0 !=i && 1 == (i%8 + 1))
            {
                buff[j++] = ' ';
            }
            buff[j++] = (0 == GETBITBI(src[i/8], i%8 + 1) ? '0' : '1');            
        }
        buff[j] = '\0';
    }
    else
    {
        sprintf(&buff[0], "op 代码错误！");
    }
    fprintf(fp,buff);
}

int main(void)
{
    int i = 0;
    byte m[8] = {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xe7};
    byte key[8] = {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};

    byte c[8] = {0,0,0,0,0,0,0,0};

    printf("m  : ");byteOtf(stdout,m,64,'h');
    printf("\nbit: ");byteOtf(stdout,m,64,'b');
    printf("\nkey: ");byteOtf(stdout,key,64,'h');
    printf("\nbit: ");byteOtf(stdout,key,64,'b');
    
    printf("\n\nencrption:");
    encrption(m, c, key, 1);

    printf("\nc  : ");byteOtf(stdout,c,64,'h');
    printf("\nbit: ");byteOtf(stdout,c,64,'b');

    printf("\n\ndecrption:");
    encrption(c, m, key, 0);

    printf("\nm  : ");byteOtf(stdout,m,64,'h');
    printf("\nbit: ");byteOtf(stdout,m,64,'b');

    printf("\n\n");
    return 0;
}
